---
layout:     post
title:      记一次defer不生效的排查
subtitle:   Golang defer
date:       2020-09-23
author:     JC
header-img: 
catalog: true
tags:
    - Golang
---

### 问题
原函数如下：
```
func Sample(){
    var err error
    defer func(e error) {
		if e != nil {
			logger.Error(e)
		}
	}(err) 

    ...
    e := DoSomething()
    if e != nil{
        err = e
        return
    }
    ...
}
```

当有错误返回给err赋值后，发现没有如期调用logger打印错误

### 排查及结论

#### defer定义和执行是两个步骤！

先说结论：会先将defer后函数的参数部分的值(或者地址)给先下来【你可以理解为()里头的会先确定】，后面函数执行完，才会执行defer后函数的{}中的逻辑

```
func test(i *int) int {
	return *i
}

func main(){
	var i = 1

	// defer定义的时候test(&i)的值就已经定了，是1，后面就不会变了
	defer fmt.Println("i1 ="  , test(&i))
	i++
    
	// defer定义的时候test(&i)的值就已经定了，是2，后面就不会变了
	defer fmt.Println("i2 ="  , test(&i))

	// defer定义的时候，i就已经确定了是一个指针类型，地址上的值变了，这里跟着变
	defer func(i *int) {
		fmt.Println("i3 ="  , *i)
	}(&i)

	// defer定义的时候i的值就已经定了，是2，后面就不会变了
	defer func(i int) {
		//defer 在定义的时候就定了
		fmt.Println("i4 ="  , i)
	}(i)

	defer func() {
		// 地址，所以后续跟着变
		var c = &i
		fmt.Println("i5 ="  , *c)
	}()
	
	// 执行了 i=11 后才调用，此时i值已是11
	defer func() {
		fmt.Println("i6 ="  , i)
	}()

	i = 11
}
```


